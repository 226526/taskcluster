version: 12
migrationScript: 0012-migration.sql
downgradeScript: 0012-downgrade.sql
methods:
  wmworkers_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(wmworkers_entities_load.row_key);
        return query
        select
          wmworkers_entities_load.partition_key,
          wmworkers_entities_load.row_key,
          entity_buf_encode(
            jsonb_build_object(
              'PartitionKey', encode_string_key(worker_pool_id),
              'RowKey', encode_composite_key(worker_group, worker_id),
              'workerPoolId', worker_pool_id,
              'workerGroup', worker_group,
              'workerId', worker_id,
              'providerId', provider_id,
              'created', created,
              'expires', expires,
              'state', state,
              'capacity', capacity,
              'lastModified', last_modified,
              'lastChecked', last_checked),
            'providerData', provider_data::text) as value,
          1 as version,
          workers.etag as etag
        from workers
        where
          workers.worker_pool_id = decode_string_key(wmworkers_entities_load.partition_key) and workers.worker_group = decoded_composite_key[1] and workers.worker_id = decoded_composite_key[2];
      end
  wmworkers_entities_create:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_row workers%ROWTYPE;
      begin
        select
          (properties ->> 'workerPoolId')::text,
          (properties ->> 'workerGroup')::text,
          (properties ->> 'workerId')::text,
          (properties ->> 'providerId')::text,
          (properties ->> 'created')::timestamptz,
          (properties ->> 'expires')::timestamptz,
          (properties ->> 'state')::text,
          entity_buf_decode(properties, 'providerData')::jsonb,
          (properties ->> 'capacity')::integer as capacity,
          (properties ->> 'lastModified')::timestamptz,
          (properties ->> 'lastChecked')::timestamptz,
          public.gen_random_uuid()
        into new_row;
        if overwrite then
          raise exception 'overwrite not implemented';
        else
          execute 'insert into workers select $1.*' using new_row;
        end if;
        return new_row.etag;
      end
  wmworkers_entities_remove:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      declare
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(wmworkers_entities_remove.row_key);
        return query delete from workers
        where
          workers.worker_pool_id = decode_string_key(wmworkers_entities_remove.partition_key) and
          workers.worker_group = decoded_composite_key[1] and
          workers.worker_id = decoded_composite_key[2]
        returning workers.etag;
      end
  wmworkers_entities_modify:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_row workers%ROWTYPE;
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(wmworkers_entities_modify.row_key);
        select
          (properties ->> 'workerPoolId')::text,
          (properties ->> 'workerGroup')::text,
          (properties ->> 'workerId')::text,
          (properties ->> 'providerId')::text,
          (properties ->> 'created')::timestamptz,
          (properties ->> 'expires')::timestamptz,
          (properties ->> 'state')::text,
          entity_buf_decode(properties, 'providerData')::jsonb,
          (properties ->> 'capacity')::integer,
          (properties ->> 'lastModified')::timestamptz,
          (properties ->> 'lastChecked')::timestamptz,
          public.gen_random_uuid() as etag
        into new_row;
        update workers
        set (
          provider_id,
          created,
          expires,
          state,
          capacity,
          last_modified,
          last_checked,
          provider_data,
          etag
        ) = (
          new_row.provider_id,
          new_row.created,
          new_row.expires,
          new_row.state,
          new_row.capacity,
          new_row.last_modified,
          new_row.last_checked,
          new_row.provider_data,
          new_row.etag
        )
        where
          workers.worker_pool_id = decode_string_key(wmworkers_entities_modify.partition_key) and
          workers.worker_group = decoded_composite_key[1] and
          workers.worker_id = decoded_composite_key[2] and
          workers.etag = wmworkers_entities_modify.old_etag;
        if found then
          return query select new_row.etag;
          return;
        end if;
        perform workers.etag from workers
        where
          workers.worker_pool_id = decode_string_key(wmworkers_entities_modify.partition_key) and
          workers.worker_group = decoded_composite_key[1] and
          workers.worker_id = decoded_composite_key[2];
        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  wmworkers_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        cond text[];
        exp_cond_operator text;
        exp_cond_operand timestamptz;
        partition_key_var text;
        row_key_var text;
        decoded_composite_key text[];
      begin
        decoded_composite_key := decode_composite_key(wmworkers_entities_scan.rk);
        if not condition is null then
          cond := regexp_split_to_array(condition, '\s+');
          exp_cond_operator := cond[4];
          exp_cond_operand := cond[5] :: timestamptz;

          return query select
            encode_string_key(worker_pool_id) as partition_key,
            encode_composite_key(worker_group, worker_id) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', encode_string_key(worker_pool_id),
                'RowKey', encode_composite_key(worker_group, worker_id),
                'workerPoolId', worker_pool_id,
                'workerGroup', worker_group,
                'workerId', worker_id,
                'providerId', provider_id,
                'created', created,
                'expires', expires,
                'state', state,
                'capacity', capacity,
                'lastModified', last_modified,
                'lastChecked', last_checked),
              'providerData', provider_data::text) as value,
            1 as version,
            workers.etag as etag from workers
          where
            (wmworkers_entities_scan.pk is null or decode_string_key(wmworkers_entities_scan.pk) = worker_pool_id) and
            (wmworkers_entities_scan.rk is null or wmworkers_entities_scan.rk = decoded_composite_key[1] || '~' || decoded_composite_key[2]) and
            case
              when exp_cond_operator = '=' then expires = exp_cond_operand
              when exp_cond_operator = '<' then expires < exp_cond_operand
              when exp_cond_operator = '<=' then expires <= exp_cond_operand
              when exp_cond_operator = '>' then expires > exp_cond_operand
              when exp_cond_operator = '>=' then expires >= exp_cond_operand
              else expires <> exp_cond_operand
            end
          order by workers.worker_pool_id, workers.worker_group, workers.worker_id
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (page is not null and page > 0) then page
            else 0
          end;
        else
          return query select
            encode_string_key(worker_pool_id) as partition_key,
            encode_composite_key(worker_group, worker_id) as row_key,
            entity_buf_encode(
              jsonb_build_object(
                'PartitionKey', encode_string_key(worker_pool_id),
                'RowKey', encode_composite_key(worker_group, worker_id),
                'workerPoolId', worker_pool_id,
                'workerGroup', worker_group,
                'workerId', worker_id,
                'providerId', provider_id,
                'created', created,
                'expires', expires,
                'state', state,
                'capacity', capacity,
                'lastModified', last_modified,
                'lastChecked', last_checked),
              'providerData', provider_data::text) as value,
            1 as version,
            workers.etag as etag from workers
          where
            (wmworkers_entities_scan.pk is null or decode_string_key(wmworkers_entities_scan.pk) = worker_pool_id) and
            (wmworkers_entities_scan.rk is null or (worker_group = decoded_composite_key[1] and worker_id = decoded_composite_key[2]))
          order by workers.worker_pool_id, workers.worker_group, workers.worker_id
          limit case
            when (size is not null and size > 0) then size + 1
            else null
          end
          offset case
            when (size is not null and size > 0 and page is not null and page > 0) then page
            else 0
          end;
        end if;
      end
